-- 1) ПАРТИЦИОНИРОВАНИЕ VS ШАРДИРОВАНИЕ

-- шардирование по факту когда мы поднимаем неск instance-ов и объединяем это все через foreign table, в данном случае общие запросы будут делаться через VIEW
-- парционирование раскидываем одну очень большую табличку на на неск маленьких, индексы, проверки, ограничения придется копировать, в данном случае запросы могут делать через MAIN TABLE (все партиционные таблички будут наследоваться через INHERITS, так же требуется использовать RULE

-- 2) TRUNCATE VS DELETE WITHOUT WHERE

--Операция TRUNCATE не записывает в журнал событий удаление отдельных строк. Вследствие чего не может активировать триггеры.
-- После операции TRUNCATE для некоторых СУБД (например, Oracle) следует неявная операция COMMIT. Поэтому удаленные в таблице записи нельзя восстановить операцией ROLLBACK. Но существуют и СУБД, в которых операция TRUNCATE может участвовать в транзакциях, например, PostgreSQL и Microsoft SQL Server.
-- Операция DELETE блокирует каждую строку, а TRUNCATE — всю таблицу.
-- Операция TRUNCATE не возвращает какого-то осмысленного значения (обычно возвращает 0) в отличие от DELETE, которая возвращает число удаленных строк.
-- Операция TRUNCATE в некоторых СУБД (например, MySQL или Microsoft SQL Server), сбрасывает значение счетчиков (для полей с AUTOINCREMENT / IDENTITY). В PostgreSQL для сброса счётчиков необходимо указывать модификатор RESTART IDENTITY.
-- Операция TRUNCATE в некоторых СУБД (например, MySQL, PostgreSQL или Microsoft SQL Server) запрещена для таблиц, содержащих внешние ключи других таблиц. В PostgreSQL существует, однако, модификатор CASCADE, который разрешает TRUNCATE в этой ситуации – данные из зависимых таблиц удаляются в той же транзакции.
-- В SQLite операция как таковая отсутствует, но есть оптимизация операции DELETE, которая «значительно ускоряет её работу, если отсутствует аргумент WHERE».
--DELETE DML команда, TRUNCATE DDL
--TRUNCATE быстрее

-- 3) FULL JOIN VS INNER JOIN

--INNER пересечение not null значений из обоих таблиц, FULL полная выборка из обоих с учетом NULL слева и справа

-- 4) VARCHAR VS CHAR

--CHAR фиксированной длины, нельзя записать в CHAR(10) поле строку менее/более 10 символов

-- 5) КЛАСТЕРИЗОВАННыЙ ИНДЕКС VS НЕКЛАСТЕРИЗОВАННыЙ ИНДЕКС (ПО УМОЛЧАНИЮ)

-- КЛАСТЕРИЗОВАННыЙ - быстрее
-- НЕКЛАСТЕРИЗОВАННыЙ - отдельный объект в таблице который указывает на исходные строки, КЛАСТЕРИЗОВАННыЙ - сортирует данные по столбцу
-- КЛАСТЕРИЗОВАННыЙ - может быть только один на всю табличку

-- 6) НОРМАЛИЗАЦИЯ, ПРЕИМУЩЕСТВА:

-- Лучшая организация базы данных
-- Больше таблиц с небольшими строками
-- Эффективный доступ к данным
-- Большая гибкость для запросов
-- Быстрый поиск информации
-- Проще реализовать безопасность данных
-- Позволяет легко модифицировать
-- Сокращение избыточных и дублирующихся данных
-- Более компактная база данных
-- Обеспечивает согласованность данных после внесения изменений

-- 7) 1НФ

-- пример
-- ФИО          НОМЕР ТЕЛЕФОНА
-- Иванов И. И. 89263334312, 3349922
--
-- нарушает первую НФ так как в одной колонке список значений, преобразуем
--
-- ФИО          НОМЕР ТЕЛЕФОНА
-- Иванов И. И. 89263334312
-- Иванов И. И. 3349922

-- 8) 2НФ

--пример

-- Отношение находится во 2НФ, если оно находится в 1НФ
-- каждый не ключевой атрибут неприводимо зависит от Первичного Ключа(убираем избыточность разделяя на подтаблицы)

-- пример
-- ID Автор        Название  Издательство  День рождения автора Телефон издательства
-- 1  Иванов И. И. Java 11   Дом книги     01.01.1991           89270044221

--много не связанных данных в одной таблице, после приведения во вторую НФ получаем:
-- Книги
-- ID Название Автор Издательство
-- 1  Java 11  1     1
--
-- Автор
-- ID ФИО          Дата рождения
-- 1  Иванов И. И. 01.01.1991
--
-- Издательство
-- ID Телефон
-- 1  89270044221

-- 9) 3НФ
--не ключевой атрибут нетранзитивно зависит от первичного ключа
--пример что выше на самом деле соответствествует и 3НФ

-- 10) Типы подзапросов
-- не кореллированный (простой):
-- этот запрос является независимым запросом, в котором выходные данные подзапроса подставляются в основной запрос.
--
-- кореллированный
-- это запрос, который выбирает данные из таблицы со ссылкой на внешний запрос. Он не считается независимым запросом, поскольку ссылается на другую таблицу или столбец в таблице.
--например INSERT FROM SELECT подзапрос из другой таблички

-- 11) Типы индексов в POSTGRES к примеру
-- B-дерево(по умолчанию), хеш, GiST, SP-GiST, GIN и BRIN
-- B-дерево задействуется при след операциях:
-- <
-- <=
-- =
-- >=
-- >
--можно использовать и для ILIKE и ~*, но только если шаблон начинается не с алфавитных символов, то есть символов, не подверженных преобразованию регистра
--TODO индексы

-- 12) Q #8) What are transactions and their controls?

-- TODO 7

--TODO view повторить
--TODO temp table повторить
--TODO update from select повторить
--TODO insert from select повторить
--TODO select from update повторить
--TODO function vs хранимые процедуры вспомнить
--TODO не средние запросы
--TODO составные индексы и их виды теорию почитать порядок там
--TODO оконные функции так повторить